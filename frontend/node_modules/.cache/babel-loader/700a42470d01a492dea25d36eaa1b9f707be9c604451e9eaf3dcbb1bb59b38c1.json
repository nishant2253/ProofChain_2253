{"ast":null,"code":"import { ethers } from \"ethers\";\n\n// ABI for the ProofChain contract\n// This is a simplified ABI for demonstration purposes\n// In a real application, you would import the full ABI from a JSON file\nconst CONTRACT_ABI = [\n// Content management functions\n\"function submitContent(string contentHash, uint256 votingDeadline) external returns (uint256)\", \"function getContent(uint256 contentId) external view returns (string, address, uint256, uint256, bool)\",\n// Voting functions\n\"function commitVote(uint256 contentId, bytes32 commitHash, string tokenType, uint256 amount) external\", \"function revealVote(uint256 contentId, bool vote, uint256 confidence, bytes32 salt) external\", \"function finalizeVoting(uint256 contentId) external\",\n// Token functions\n\"function getSupportedTokens() external view returns (string[] memory)\", \"function getTokenPrice(string memory tokenType) external view returns (uint256)\",\n// Events\n\"event ContentSubmitted(uint256 indexed contentId, address indexed submitter, string contentHash)\", \"event VoteCommitted(uint256 indexed contentId, address indexed voter, bytes32 commitHash)\", \"event VoteRevealed(uint256 indexed contentId, address indexed voter, bool vote, uint256 confidence)\", \"event VotingFinalized(uint256 indexed contentId, bool result)\"];\n\n// Get contract address from environment variables\nconst CONTRACT_ADDRESS = process.env.REACT_APP_CONTRACT_ADDRESS;\n\n/**\n * Get contract instance with signer or provider\n * @param {ethers.providers.Web3Provider|ethers.Signer} signerOrProvider - Signer or provider\n * @returns {ethers.Contract} Contract instance\n */\nexport const getContract = signerOrProvider => {\n  if (!CONTRACT_ADDRESS) {\n    throw new Error(\"Contract address not defined in environment variables\");\n  }\n  return new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signerOrProvider);\n};\n\n/**\n * Submit content to the blockchain\n * @param {ethers.Signer} signer - Signer for the transaction\n * @param {string} contentHash - IPFS hash of the content\n * @param {number} votingDeadline - Timestamp for voting deadline\n * @returns {Promise<ethers.providers.TransactionResponse>} Transaction response\n */\nexport const submitContentToBlockchain = async (signer, contentHash, votingDeadline) => {\n  const contract = getContract(signer);\n  const tx = await contract.submitContent(contentHash, votingDeadline);\n  return tx;\n};\n\n/**\n * Commit vote to the blockchain\n * @param {ethers.Signer} signer - Signer for the transaction\n * @param {number} contentId - Content ID\n * @param {string} commitHash - Hash of vote, confidence, and salt\n * @param {string} tokenType - Token type for voting\n * @param {string} amount - Amount of tokens to stake\n * @returns {Promise<ethers.providers.TransactionResponse>} Transaction response\n */\nexport const commitVoteToBlockchain = async (signer, contentId, commitHash, tokenType, amount) => {\n  const contract = getContract(signer);\n  const tx = await contract.commitVote(contentId, commitHash, tokenType, amount);\n  return tx;\n};\n\n/**\n * Reveal vote on the blockchain\n * @param {ethers.Signer} signer - Signer for the transaction\n * @param {number} contentId - Content ID\n * @param {boolean} vote - Vote (true/false)\n * @param {number} confidence - Confidence level\n * @param {string} salt - Random salt used in commit\n * @returns {Promise<ethers.providers.TransactionResponse>} Transaction response\n */\nexport const revealVoteOnBlockchain = async (signer, contentId, vote, confidence, salt) => {\n  const contract = getContract(signer);\n  const tx = await contract.revealVote(contentId, vote, confidence, salt);\n  return tx;\n};\n\n/**\n * Finalize voting on the blockchain\n * @param {ethers.Signer} signer - Signer for the transaction\n * @param {number} contentId - Content ID\n * @returns {Promise<ethers.providers.TransactionResponse>} Transaction response\n */\nexport const finalizeVotingOnBlockchain = async (signer, contentId) => {\n  const contract = getContract(signer);\n  const tx = await contract.finalizeVoting(contentId);\n  return tx;\n};\n\n/**\n * Generate commit hash for voting\n * @param {boolean} vote - Vote (true/false)\n * @param {number} confidence - Confidence level\n * @param {string} salt - Random salt\n * @returns {string} Commit hash\n */\nexport const generateCommitHash = (vote, confidence, salt) => {\n  // Convert vote to uint (0 or 1)\n  const voteValue = vote ? 1 : 0;\n\n  // Pack the values and hash them\n  const packedData = ethers.utils.solidityPack([\"uint8\", \"uint256\", \"bytes32\"], [voteValue, confidence, ethers.utils.id(salt)]);\n  return ethers.utils.keccak256(packedData);\n};\n\n/**\n * Generate a random salt for commit-reveal scheme\n * @returns {string} Random salt\n */\nexport const generateRandomSalt = () => {\n  return ethers.utils.hexlify(ethers.utils.randomBytes(32));\n};\n\n/**\n * Listen for contract events\n * @param {ethers.providers.Web3Provider} provider - Provider for listening to events\n * @param {string} eventName - Name of the event to listen for\n * @param {Function} callback - Callback function for event\n * @returns {ethers.providers.EventListener} Event listener\n */\nexport const listenForEvents = (provider, eventName, callback) => {\n  const contract = getContract(provider);\n  contract.on(eventName, callback);\n\n  // Return a function to remove the listener\n  return () => {\n    contract.off(eventName, callback);\n  };\n};\n\n/**\n * Check if the connected wallet is on the correct network\n * @param {ethers.providers.Web3Provider} provider - Web3 provider\n * @returns {Promise<boolean>} True if on correct network\n */\nexport const isCorrectNetwork = async provider => {\n  const targetChainId = parseInt(process.env.REACT_APP_CHAIN_ID || \"1337\");\n  const network = await provider.getNetwork();\n  return network.chainId === targetChainId;\n};","map":{"version":3,"names":["ethers","CONTRACT_ABI","CONTRACT_ADDRESS","process","env","REACT_APP_CONTRACT_ADDRESS","getContract","signerOrProvider","Error","Contract","submitContentToBlockchain","signer","contentHash","votingDeadline","contract","tx","submitContent","commitVoteToBlockchain","contentId","commitHash","tokenType","amount","commitVote","revealVoteOnBlockchain","vote","confidence","salt","revealVote","finalizeVotingOnBlockchain","finalizeVoting","generateCommitHash","voteValue","packedData","utils","solidityPack","id","keccak256","generateRandomSalt","hexlify","randomBytes","listenForEvents","provider","eventName","callback","on","off","isCorrectNetwork","targetChainId","parseInt","REACT_APP_CHAIN_ID","network","getNetwork","chainId"],"sources":["/home/nishant/proofchain/frontend/src/utils/blockchain.js"],"sourcesContent":["import { ethers } from \"ethers\";\n\n// ABI for the ProofChain contract\n// This is a simplified ABI for demonstration purposes\n// In a real application, you would import the full ABI from a JSON file\nconst CONTRACT_ABI = [\n  // Content management functions\n  \"function submitContent(string contentHash, uint256 votingDeadline) external returns (uint256)\",\n  \"function getContent(uint256 contentId) external view returns (string, address, uint256, uint256, bool)\",\n\n  // Voting functions\n  \"function commitVote(uint256 contentId, bytes32 commitHash, string tokenType, uint256 amount) external\",\n  \"function revealVote(uint256 contentId, bool vote, uint256 confidence, bytes32 salt) external\",\n  \"function finalizeVoting(uint256 contentId) external\",\n\n  // Token functions\n  \"function getSupportedTokens() external view returns (string[] memory)\",\n  \"function getTokenPrice(string memory tokenType) external view returns (uint256)\",\n\n  // Events\n  \"event ContentSubmitted(uint256 indexed contentId, address indexed submitter, string contentHash)\",\n  \"event VoteCommitted(uint256 indexed contentId, address indexed voter, bytes32 commitHash)\",\n  \"event VoteRevealed(uint256 indexed contentId, address indexed voter, bool vote, uint256 confidence)\",\n  \"event VotingFinalized(uint256 indexed contentId, bool result)\",\n];\n\n// Get contract address from environment variables\nconst CONTRACT_ADDRESS = process.env.REACT_APP_CONTRACT_ADDRESS;\n\n/**\n * Get contract instance with signer or provider\n * @param {ethers.providers.Web3Provider|ethers.Signer} signerOrProvider - Signer or provider\n * @returns {ethers.Contract} Contract instance\n */\nexport const getContract = (signerOrProvider) => {\n  if (!CONTRACT_ADDRESS) {\n    throw new Error(\"Contract address not defined in environment variables\");\n  }\n\n  return new ethers.Contract(CONTRACT_ADDRESS, CONTRACT_ABI, signerOrProvider);\n};\n\n/**\n * Submit content to the blockchain\n * @param {ethers.Signer} signer - Signer for the transaction\n * @param {string} contentHash - IPFS hash of the content\n * @param {number} votingDeadline - Timestamp for voting deadline\n * @returns {Promise<ethers.providers.TransactionResponse>} Transaction response\n */\nexport const submitContentToBlockchain = async (\n  signer,\n  contentHash,\n  votingDeadline\n) => {\n  const contract = getContract(signer);\n  const tx = await contract.submitContent(contentHash, votingDeadline);\n  return tx;\n};\n\n/**\n * Commit vote to the blockchain\n * @param {ethers.Signer} signer - Signer for the transaction\n * @param {number} contentId - Content ID\n * @param {string} commitHash - Hash of vote, confidence, and salt\n * @param {string} tokenType - Token type for voting\n * @param {string} amount - Amount of tokens to stake\n * @returns {Promise<ethers.providers.TransactionResponse>} Transaction response\n */\nexport const commitVoteToBlockchain = async (\n  signer,\n  contentId,\n  commitHash,\n  tokenType,\n  amount\n) => {\n  const contract = getContract(signer);\n  const tx = await contract.commitVote(\n    contentId,\n    commitHash,\n    tokenType,\n    amount\n  );\n  return tx;\n};\n\n/**\n * Reveal vote on the blockchain\n * @param {ethers.Signer} signer - Signer for the transaction\n * @param {number} contentId - Content ID\n * @param {boolean} vote - Vote (true/false)\n * @param {number} confidence - Confidence level\n * @param {string} salt - Random salt used in commit\n * @returns {Promise<ethers.providers.TransactionResponse>} Transaction response\n */\nexport const revealVoteOnBlockchain = async (\n  signer,\n  contentId,\n  vote,\n  confidence,\n  salt\n) => {\n  const contract = getContract(signer);\n  const tx = await contract.revealVote(contentId, vote, confidence, salt);\n  return tx;\n};\n\n/**\n * Finalize voting on the blockchain\n * @param {ethers.Signer} signer - Signer for the transaction\n * @param {number} contentId - Content ID\n * @returns {Promise<ethers.providers.TransactionResponse>} Transaction response\n */\nexport const finalizeVotingOnBlockchain = async (signer, contentId) => {\n  const contract = getContract(signer);\n  const tx = await contract.finalizeVoting(contentId);\n  return tx;\n};\n\n/**\n * Generate commit hash for voting\n * @param {boolean} vote - Vote (true/false)\n * @param {number} confidence - Confidence level\n * @param {string} salt - Random salt\n * @returns {string} Commit hash\n */\nexport const generateCommitHash = (vote, confidence, salt) => {\n  // Convert vote to uint (0 or 1)\n  const voteValue = vote ? 1 : 0;\n\n  // Pack the values and hash them\n  const packedData = ethers.utils.solidityPack(\n    [\"uint8\", \"uint256\", \"bytes32\"],\n    [voteValue, confidence, ethers.utils.id(salt)]\n  );\n\n  return ethers.utils.keccak256(packedData);\n};\n\n/**\n * Generate a random salt for commit-reveal scheme\n * @returns {string} Random salt\n */\nexport const generateRandomSalt = () => {\n  return ethers.utils.hexlify(ethers.utils.randomBytes(32));\n};\n\n/**\n * Listen for contract events\n * @param {ethers.providers.Web3Provider} provider - Provider for listening to events\n * @param {string} eventName - Name of the event to listen for\n * @param {Function} callback - Callback function for event\n * @returns {ethers.providers.EventListener} Event listener\n */\nexport const listenForEvents = (provider, eventName, callback) => {\n  const contract = getContract(provider);\n  contract.on(eventName, callback);\n\n  // Return a function to remove the listener\n  return () => {\n    contract.off(eventName, callback);\n  };\n};\n\n/**\n * Check if the connected wallet is on the correct network\n * @param {ethers.providers.Web3Provider} provider - Web3 provider\n * @returns {Promise<boolean>} True if on correct network\n */\nexport const isCorrectNetwork = async (provider) => {\n  const targetChainId = parseInt(process.env.REACT_APP_CHAIN_ID || \"1337\");\n  const network = await provider.getNetwork();\n  return network.chainId === targetChainId;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}